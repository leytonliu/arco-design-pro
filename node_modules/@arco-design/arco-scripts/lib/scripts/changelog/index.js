"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const axios_1 = __importDefault(require("axios"));
const inquirer_1 = __importDefault(require("inquirer"));
const moment_1 = __importDefault(require("moment"));
const nunjucks_1 = require("nunjucks");
const utils_1 = require("./utils");
const nunjucksEnv = (0, nunjucks_1.configure)(__dirname, {
    autoescape: false,
    trimBlocks: true,
    lstripBlocks: true,
});
const typeMap = {
    'New feature': 'feature',
    'Bug fix': 'bugfix',
    'Documentation change': 'unused',
    'Coding style change': 'unused',
    Refactoring: 'unused',
    'Component style change': 'style',
    'Performance improvement': 'optimization',
    'Test cases': 'unused',
    'Continuous integration': 'unused',
    'Typescript definition change': 'typescript',
    'Breaking change': 'attention',
    Other: 'unused',
};
const getRecords = (mr) => {
    var _a, _b;
    const content = mr.body.replace(/\r\n/g, '\n');
    const records = [];
    const typeRule = new RegExp('## Types of changes.+?\\[[xX]] (.+?)\\n', 's');
    const typeString = ((_b = (_a = content.match(typeRule)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : '').trim();
    const type = typeMap[typeString];
    if (type && type !== 'unused') {
        const rule = new RegExp(
        // Table title
        '## Changelog\\n\\n' +
            // Table title
            '\\|(.+)\\|\\n' +
            // Alignment info
            '\\|(?:[-: ]+[-| :]*)\\|\\n' +
            // Table content
            '((?:\\|.*\\|(?:\\n|$))*)');
        const matchResult = content.match(rule);
        if (matchResult) {
            const titles = matchResult[1].split('|').map((item) => item.toLowerCase().trim());
            const lines = matchResult[2].split('\n').filter((value) => Boolean(value.trim()));
            for (const line of lines) {
                const items = line
                    .split('|')
                    .slice(1)
                    .map((value) => value.trim());
                const data = titles.reduce((data, title, index) => {
                    var _a;
                    switch (title) {
                        case 'type':
                            data[title] = items[index].toLowerCase();
                            break;
                        case 'related issues': {
                            const match = ((_a = items[index]) !== null && _a !== void 0 ? _a : '').match(/#\d+/g);
                            if (match) {
                                data.issue = match.map((item) => item.slice(1));
                            }
                            break;
                        }
                        default:
                            data[title] = items[index];
                    }
                    return data;
                }, {
                    mrId: mr.number,
                    mrURL: mr.html_url,
                    type,
                });
                records.push(data);
            }
        }
    }
    return records;
};
const addAll = (data, changelog) => {
    if (!changelog[data.type]) {
        changelog[data.type] = [];
    }
    changelog[data.type].push(data.content);
};
const addComponent = (data, changelog) => {
    const component = data.component || 'common';
    if (!changelog[component]) {
        changelog[component] = {};
    }
    if (!changelog[component][data.type]) {
        changelog[component][data.type] = [];
    }
    changelog[component][data.type].push(data.content);
};
const deleteChangelog = (filename, versions) => {
    const content = fs_extra_1.default.readFileSync(filename, 'utf8');
    const reg = new RegExp(`## (${versions.join('|').replace(/\./g, '\\.')}).+?(?=## \\d+\\.\\d+\\.\\d+(-beta\\.\\d+)?)`, 'gs');
    const result = content.replace(reg, '');
    fs_extra_1.default.writeFileSync(filename, result);
};
const getEmitsFromChangelog = (changelog) => __awaiter(void 0, void 0, void 0, function* () {
    const allCN = {};
    const addEN = {};
    const componentCN = {};
    const componentEN = {};
    for (const item of changelog.list) {
        if (!(0, utils_1.isValidComponent)(item.component)) {
            // eslint-disable-next-line no-await-in-loop
            const answer = yield inquirer_1.default.prompt({
                type: 'input',
                name: 'component',
                message: `The component name '${item.component}' is invalid, please input the new name.[${item.mrId}]`,
                validate(input) {
                    return (0, utils_1.isValidComponent)(input);
                },
            });
            item.component = answer.component;
        }
        const contentCN = `${item['changelog(cn)']}([#${item.mrId}](${item.mrURL}))`;
        const contentEN = `${item['changelog(en)']}([#${item.mrId}](${item.mrURL}))`;
        addAll(Object.assign(Object.assign({}, item), { content: contentCN }), allCN);
        addAll(Object.assign(Object.assign({}, item), { content: contentEN }), addEN);
        addComponent(Object.assign(Object.assign({}, item), { content: contentCN }), componentCN);
        addComponent(Object.assign(Object.assign({}, item), { content: contentEN }), componentEN);
    }
    const emits = [
        {
            filename: 'site/docs/version_v2.zh-CN.md',
            template: 'template/main.zh-CN.njk',
            data: Object.assign({ version: changelog.version, date: changelog.date }, allCN),
        },
        {
            filename: 'site/docs/version_v2.en-US.md',
            template: 'template/main.en-US.njk',
            data: Object.assign({ version: changelog.version, date: changelog.date }, addEN),
        },
    ];
    for (const component of Object.keys(componentCN)) {
        let filepath = `components/${component}/__changelog__/index.zh-CN.md`;
        if (/common/i.test(component)) {
            filepath = 'site/docs/changelog.common.zh-CN.md';
        }
        else if (/icon/.test(component)) {
            filepath = 'site/src/pages/icon/md/__changelog__/index.zh-CN.md';
        }
        emits.push({
            filename: filepath,
            template: 'template/main.zh-CN.njk',
            data: Object.assign({ version: changelog.version, date: changelog.date }, componentCN[component]),
        });
    }
    for (const component of Object.keys(componentEN)) {
        let filepath = `./components/${component}/__changelog__/index.en-US.md`;
        if (/common/i.test(component)) {
            filepath = 'site/docs/changelog.common.en-US.md';
        }
        else if (/icon/.test(component)) {
            filepath = 'site/src/pages/icon/md/__changelog__/index.en-US.md';
        }
        emits.push({
            filename: filepath,
            template: 'template/main.en-US.njk',
            data: Object.assign({ version: changelog.version, date: changelog.date }, componentEN[component]),
        });
    }
    return emits;
});
const appendChangelog = (emit) => {
    const { filename, template, data } = emit;
    const content = nunjucksEnv.render(template, data);
    try {
        fs_extra_1.default.accessSync(filename);
    }
    catch (_a) {
        fs_extra_1.default.writeFileSync(filename, content);
    }
    const origin = fs_extra_1.default.readFileSync(filename, 'utf8');
    let originContent = origin;
    let hasFm = false;
    if (origin.match(/^---\nchangelog:\s*true\n---\n\n/)) {
        hasFm = true;
        originContent = origin.replace(/^---\nchangelog:\s*true\n---\n\n/, '');
    }
    const result = (hasFm ? '---\nchangelog: true\n---\n\n' : '') + content + originContent;
    fs_extra_1.default.writeFileSync(filename, result);
};
const getLastVersion = (content) => {
    const match = content.match(/## (\d+\.\d+\.\d+(-beta\.\d+)?)/);
    if (match) {
        return match[1];
    }
};
const getBetaVersions = (content) => {
    const matches = Array.from(content.matchAll(/## (\d+\.\d+\.\d+(-beta\.\d+)?)/g));
    const versions = [];
    for (const item of matches) {
        if (/beta/.test(item[1])) {
            versions.push(item[1]);
        }
        else {
            break;
        }
    }
    return versions;
};
const run = () => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d;
    let version;
    if (fs_extra_1.default.existsSync('package.json')) {
        try {
            const packageJson = yield fs_extra_1.default.readFile('package.json', 'utf8');
            const packageData = JSON.parse(packageJson);
            if (packageData.version) {
                version = packageData.version;
            }
        }
        catch (_e) {
            console.log('read version from package.json has error');
        }
    }
    const answer = yield inquirer_1.default.prompt({
        type: 'input',
        name: 'version',
        message: 'Please input the version',
        default: version,
        validate(input) {
            return /\d+\.\d+\.\d+(-beta\.\d+)?/.test(input);
        },
    });
    version = answer.version;
    const currentContent = fs_extra_1.default.readFileSync('site/docs/version_v2.zh-CN.md', 'utf8');
    const lastVersion = getLastVersion(currentContent);
    let needMerge = false;
    if (version === lastVersion || (0, utils_1.compareVersion)(version, lastVersion) < 1) {
        const answer = yield inquirer_1.default.prompt({
            type: 'input',
            name: 'version',
            message: `This version is already existed or lower than last version, please reenter`,
            validate(input) {
                return /\d+\.\d+\.\d+(-beta\.\d+)?/.test(input) && input !== lastVersion;
            },
        });
        version = answer.version;
    }
    if (/beta/.test(lastVersion)) {
        const answer = yield inquirer_1.default.prompt({
            type: 'confirm',
            name: 'merge',
            message: `This last version is a beta, is need to merge?`,
        });
        needMerge = answer.merge;
    }
    const res = yield axios_1.default.get(`https://api.github.com/search/issues?accept=application/vnd.github.v3+json&q=repo:arco-design/arco-design+is:pr+is:merged+milestone:${version}`);
    if (res.status === 200) {
        let { data } = res;
        data = data === null || data === void 0 ? void 0 : data.items;
        if (needMerge) {
            const betaVersions = getBetaVersions(currentContent);
            console.log(`there are ${betaVersions.length} version need to merge: ${betaVersions.join(',')}`);
            const files = new Set(['site/docs/version_v2.zh-CN.md', 'site/docs/version_v2.en-US.md']);
            for (const betaVersion of betaVersions) {
                // eslint-disable-next-line no-await-in-loop
                const res2 = yield axios_1.default.get(`https://api.github.com/search/issues?accept=application/vnd.github.v3+json&q=repo:arco-design/arco-design+is:pr+is:merged+milestone:${betaVersion}`);
                if (res2.status === 200) {
                    data = data.concat((_b = (_a = res2.data) === null || _a === void 0 ? void 0 : _a.items) !== null && _b !== void 0 ? _b : []);
                    for (const item of (_d = (_c = res2.data) === null || _c === void 0 ? void 0 : _c.items) !== null && _d !== void 0 ? _d : []) {
                        const records = getRecords(item);
                        for (const record of records) {
                            let component = record.component;
                            if (!(0, utils_1.isValidComponent)(component)) {
                                // eslint-disable-next-line no-await-in-loop
                                const answer = yield inquirer_1.default.prompt({
                                    type: 'input',
                                    name: 'component',
                                    message: `The component name '${component}' is invalid, please input the new name.[${record.mrId}]`,
                                    validate(input) {
                                        return (0, utils_1.isValidComponent)(input);
                                    },
                                });
                                component = answer.component;
                            }
                            let filepath = `components/${component}/__changelog__/index.zh-CN.md`;
                            if (/common/i.test(component)) {
                                filepath = 'site/docs/changelog.common.zh-CN.md';
                            }
                            else if (/icon/.test(component)) {
                                filepath = 'site/src/pages/icon/md/__changelog__/index.zh-CN.md';
                            }
                            let filepath2 = `./components/${component}/__changelog__/index.en-US.md`;
                            if (/common/i.test(component)) {
                                filepath2 = 'site/docs/changelog.common.en-US.md';
                            }
                            else if (/icon/.test(component)) {
                                filepath2 = 'site/src/pages/icon/md/__changelog__/index.en-US.md';
                            }
                            files.add(filepath);
                            files.add(filepath2);
                        }
                    }
                }
            }
            files.forEach((file) => deleteChangelog(file, betaVersions));
        }
        const changelog = {
            version,
            date: (0, moment_1.default)().format('YYYY-MM-DD'),
            list: [],
        };
        for (const item of data) {
            const records = getRecords(item);
            changelog.list.push(...records);
        }
        if (changelog.list.length > 0) {
            const emits = yield getEmitsFromChangelog(changelog);
            for (const item of emits) {
                // eslint-disable-next-line no-await-in-loop
                yield appendChangelog(item);
            }
        }
        else {
            console.log('No update information found');
        }
    }
});
exports.default = run;
